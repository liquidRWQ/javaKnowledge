1.悲观锁和乐观锁

悲观锁是以一个悲观的态度，假设一定会出现线程冲突而设计的锁，比如synchronized就是悲观锁
乐观锁是以一个乐观的态度，假设不会出现线程冲突而设计的锁，比如CAS就是一种乐观锁




2.线程安全

多个线程访问同一段代码，这段代码执行后不会产生不确定的结果，就是线程安全的

3.并发和并行
并发：当有多个线程在操作时,如果系统只有一个CPU,把CPU运行时间划分成若干个时间段,分配给各个线程执行（间隔发生），在一个时间段的线程代码运行时，其它线程处于挂起状态。这种方式我们称之为并发(Concurrent)。
并行：当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。  

3.ThreadLocal原理

ThreadLocal存储变量，使该变量属于线程私有，其他线程无法访问该变量，一定程度上保证了线程安全。

原理：
ThreadLocal有一个内部类ThreadLocalMap，当使用ThreadLocal的set方法时就会把ThreadLocal对象自己作为key，存储的变量作为value放到ThreadLocalMap中，
而Thread类维护了这个ThreadLocalMap，使得每个线程对象都有对应的ThreadLocalMap对象，也就使该变量和线程一一对应，不受其他线程的影响。
不过由于Thread维护了ThreadLocalMap,导致ThreadLocalMap的生命周期和Thread一样长，容易导致内存泄漏。可以调用ThreadLocal的remove方法把存储的键值对删掉

4.volatile原理

volatile保证了可见性和有序性，但不能保证原子性

有序性指防止jvm优化对指令的重排。
可见性原理是：
jvm将变量存储到主内存中，并针对每个线程都分配有一个工作内存，各个线程之间的工作内存都不可见，如果变量没有加volatile，每个线程对变量的读写操作都会先在工作内存中进行，一段时间
后才刷新到主内存中，加了volatile之后，每个线程对该变量的读写操作都立刻刷新到主内存中，使其他线程读取到的是最新的值，修改的值也立即刷新，实现了可见性。

5.synchronized的用法

加在代码块上，可以选择任何对象加锁;
加在方法上，对当前方法所在类的实例加锁，在一个线程通过该类的一个实例访问该方法时，其他通过该实例访问该方法的线程都会被阻塞，但该类的其他实例仍然能访问该方法。
加在静态方法上，对当前类加锁，锁对象是类的字节码文件对象，一旦有一个线程在访问该方法，其他方法的线程就会被阻塞。
类锁和对象锁不冲突。
synchronized底层通过monitor监视器来实习，监视器存储了有关线程的信息，实现了线程安全。


6.AQS

AQS是同步器。它底层由队列和state状态实现，是锁的框架，有独占模式和共享模式。state状态值用volatile和CAS算法来实现

7.ReentrantLock
比较灵活的锁，用lock方法加锁，用unlock方法解锁，继承了AQS同步器，支持公平锁和非公平锁

8.ReentrantReadWriteLock
读写锁，继承了AQS同步器，维护了一对锁，读锁可以进入临界区，写锁是独占的，支持公平锁和非公平锁。

线程池
线程的集合，防止频繁创建和销毁线程花费时间和系统资源，用来管理线程，提高性能。

JDK提供了Executor线程池框架，它的子接口ExecutorService规定了线程池生命周期的管理方法
ThreadPoolExecutor是线程池的实现类，通过其构造方法可以创建线程池，用execute方法新建线程，用shutdown方法关闭线程池。
