1.悲观锁和乐观锁

悲观锁是以一个悲观的态度，假设一定会出现线程冲突而设计的锁，比如synchronized就是悲观锁
乐观锁是以一个乐观的态度，假设不会出现线程冲突而设计的锁，比如CAS就是一种乐观锁




2.线程安全

多个线程访问同一段代码，这段代码执行后不会产生不确定的结果，就是线程安全的

3.并发和并行
并发：多个事件在同一实体和同一时间段内间隔发生。
并行：多个事件在不同实体上同时发生

3.ThreadLocal原理

ThreadLocal存储变量，使该变量属于线程私有，其他线程无法访问该变量，一定程度上保证了线程安全。

原理：
ThreadLocal有一个内部类ThreadLocalMap，当使用ThreadLocal的set方法时就会把ThreadLocal对象自己作为key，存储的变量作为value放到ThreadLocalMap中，
而Thread类维护了这个ThreadLocalMap，使得每个线程对象都有对应的ThreadLocalMap对象，也就使该变量和线程一一对应，不受其他线程的影响。
不过由于Thread维护了ThreadLocalMap,导致ThreadLocalMap的生命周期和Thread一样长，容易导致内存泄漏。可以调用ThreadLocal的remove方法把存储的键值对删掉

4.volatile原理

volatile保证了可见性和有序性，但不能保证原子性

有序性指防止jvm优化对指令的重排。
可见性原理是：
jvm将变量存储到主内存中，并针对每个线程都分配有一个工作内存，各个线程之间的工作内存都不可见，如果变量没有加volatile，每个线程对变量的读写操作都会先在工作内存中进行，一段时间
后才刷新到主内存中，加了volatile之后，每个线程对该变量的读写操作都立刻刷新到主内存中，使其他线程读取到的是最新的值，修改的值也立即刷新，实现了可见性。

5.synchronized的用法

加在代码块上，可以选择任何对象加锁;
加在方法上，对当前方法所在类的实例加锁，在一个线程通过该类的一个实例访问该方法时，其他通过该实例访问该方法的线程都会被阻塞，但该类的其他实例仍然能访问该方法。
加在静态方法上，对当前类加锁，锁对象是类的字节码文件对象，一旦有一个线程在访问该方法，其他方法的线程就会被阻塞。
类锁和对象锁不冲突。
synchronized底层通过monitor监视器来实习，监视器存储了有关线程的信息，实现了线程安全。


6.AQS

AQS是同步器。它底层由队列和state状态实现，是锁的框架，有独占模式和共享模式。state状态值用volatile和CAS算法来实现

7.ReentrantLock
比较灵活的锁，用lock方法加锁，用unlock方法解锁，继承了AQS同步器，支持公平锁和非公平锁

8.ReentrantReadWriteLock
读写锁，继承了AQS同步器，维护了一对锁，读锁可以进入临界区，写锁是独占的，支持公平锁和非公平锁。

9.线程池
线程的集合，防止频繁创建和销毁线程花费时间和系统资源，用来管理线程，提高性能。

JDK提供了Executor线程池框架，它的子接口ExecutorService规定了线程池生命周期的管理方法
ThreadPoolExecutor是线程池的实现类，通过其构造方法可以创建线程池，用execute方法新建线程，用shutdown方法关闭线程池。


10.CAS算法

将内存值和变量的预期值做比较，如果相等说明没有其他线程修改过，就对变量进行修改，如果变量的内存值和预期值不一样，说明之前有线程先修改的了该变量，
所以尝试重新获取变量的预期值重新执行CAS操作（自旋），或者结束操作失败的线程，不进行修改。

CAS会发生ABA问题，就是一个线程在判断变量预期值和内存值相同前，可能有其他几个线程已经对该变量进行了修改，而综合修改后变量的内存值反而没有变化，
导致该线程认为变量没有被修改过而进行修改，导致该线程无法得知之前线程的操作，从而有了风险。
解决方法，给变量加版本，用AtomicStampedReference

11.Atomic

Atomic包中有实现原子性的基本数据类型的引用对象，他们都底层都是用CAS算法实现原子性的。
