1. 说一说gc的原理

首先，jaca的gc采用可达性分析算法，对gc root搜索不到的，并在第一次标记清理执行finalize方法后没有复活的对象会进行垃圾回收。
其次，gc把堆内存分成新生代，老年代进行管理。 新生代有一个Eden区和From区和To区，jvm首先把对象放到Eden区，如果Eden区满了就把对象放到from区
如果都满了就会执行一次minor gc操作，回收垃圾对象，此时，Eden区存活的对象都会复制到To区，而From区存活的对象如果达到年龄阈值（默认是15）就会被移动到老年代，没有
达到年龄阈值的对象就会复制到to区。此时，From区和To区交换角色，使To区是空的。 重复这样的操作，直到To区满后，新生代所有存活的对象都会移动到老年代中。
如果在对象移动到老年代的过程中发现老年代的剩余空间不足，jvm就会执行一次full gc来获取老年代区域的空间


2.对象的年龄阈值怎么计算？

新生代的对象每被垃圾回收一次，年龄阈值就加1。年龄阈值可以通过设置JVM参数来设置。

3.新生代Eden区，From区，To区的大小比例是多少？

默认是8:1:1，也可以通过JVM设置参数来设置比例大小

4. gc root有哪些？
可以是java虚拟栈引用的对象，本地方法栈引用的对象，方法区中静态属性引用的对象和常量引用的对象。

5.垃圾回收算法有哪些？

引用计算法 ，计数器增加对象引用就加1，减少对象引用就减1。 计数器是0时垃圾回收
问题：
频繁加减增加系统压力。
无法回收循环引用的对象。

可达性分析算法

java gc采用的算法。通过gc root搜索对象，搜素不到又没有复活的对象被执行垃圾回收


复制算法（新生代）0

将内存空间分成2块，垃圾回收时将一块内存中存活的对象复制到另一块内存中，并清空原先的内存的对象，交换两个内存的角色。
优点：内存没有碎片
缺点：浪费内存空间，效率不能保证

标记清除法

将垃圾回收分成两个阶段，第一个阶段标记gc root搜索到的对象，未标记的对象就是垃圾对象，第二个阶段，清除未标记的垃圾对象。
缺点： 会产生内存碎片

标记整理法（老年代）

将垃圾回收分成三个阶段，第一阶段标记gc root搜索到的对象，未标记的对象就是垃圾对象，第二阶段，将标记的对象集中在一起，确认内存的开始地址和结束地址，
第三阶段，清除未标记的垃圾对象。
优点： 内存没有碎片
缺点： 压缩阶段增加系统压力






